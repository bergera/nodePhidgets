<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>lib/phidgets.js - phidgets</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="phidgets" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.5.0-alpha.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Phidget.html">Phidget</a></li>
                                <li><a href="../classes/PhidgetInterfaceKit.html">PhidgetInterfaceKit</a></li>
                                <li><a href="../classes/PhidgetLED.html">PhidgetLED</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/phidgets.html">phidgets</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: lib/phidgets.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x27;use strict&#x27;;

var net = require(&#x27;net&#x27;);
var util = require(&#x27;util&#x27;);
var EventEmitter = require(&#x27;events&#x27;).EventEmitter;

/**
 * The &#x60;Phidgets&#x60; library module makes it easy to connect to a variety of boards made by
 * [Phidgets Inc.](http://www.phidgets.com)
 *
 * @module phidgets
 *
 *
 * @todo add support for connecting to a board by label.
 * @todo add support for authentication
 * @todo complete close function
 * @todo understand what lid0 does ?!
 * @todo implement a decent toString() method
 * @todo get rid of data and put innput, output and sensors at the top
 * @todo make label, serial and name read-omly
 *
 *
 * done: chainable, timeout if no connection, module, recovers when server goes down or
 * device unplugged, name and label retrieved from server
 */
var phidgets = {};

/**
 * The Phidget class is an abstract class providing common properties and methods to all
 * the board-specific child classes. This class cannot be instantiated directly. Please
 * instantiate one of the child classes instead (PhidgetInterfaceKit, PhidgetLED, etc.).
 *
 * @class Phidget
 * @constructor
 */
var Phidget = function(type) {

  if (this.constructor === Phidget) {
    throw new Error(&quot;This class is abstract, you cannot instantiate it directly.&quot;);
  }

  /**
   * Array of all the devices supported by this library.
   * @type {string[]}
   */
  this.supportedDevices = [
    &#x27;PhidgetInterfaceKit&#x27;,
    &#x27;PhidgetLED&#x27;
  ];

  if (this.supportedDevices.indexOf(type) &lt; 0) {
    throw new Error(&quot;Unsupported device type&quot;);
  }

  /**
   * The type of device (i.e. PhidgetInterfaceKit, PhidgetLED, etc.)
   * @property type
   * @type {String}
   */
  this.type = type;

  /**
   * Whether the device is ready for use or not. A device must be &#x27;opened&#x27; before it can
   * be used.
   * @property ready
   * @type {Boolean}
   * @default false
   */
  this.ready = false;

  /**
   * Whether to try automatically reopen the device if it gets remotely closed.
   * @property reopen
   * @type {Boolean}
   * @default true
   */
  this.reopen = true;

  /**
   * The host name or address of the Phidgets webservice to connect to.
   * @property host
   * @type {String}
   * @default 127.0.0.1
   */
  this.host = &quot;127.0.0.1&quot;;

  /**
   * The port of the Phidgets webservice to connect to.
   * @property port
   * @type {int}
   * @default 5001
   */
  this.port = 5001;

  /**
   * The unique serial number of the device. This is undefined until the device is opened.
   * @property serial
   * @type {int}
   * @default undefined
   */
  this.serial = undefined;

  /**
   * The unique label of the device. This is undefined until the device is opened.
   * @property label
   * @type {String}
   * @default undefined
   */
  this.label = undefined;

  /**
   * Human-readable version of the board&#x27;s name (i.e. &quot;Phidget InterfaceKit 8/8/8&quot;. This
   * information is only available after the connection has been successfully opened.
   * @type {String}
   * @default undefined
   */
  this.name = undefined;

  this._client = null;
  this._randomId = Math.floor(Math.random() * 99999);
  this._socketDataString = &#x27;&#x27;;
  this._protocol = &quot;1.0.10&quot;;
  this._delimiter = &#x27;\r\n&#x27;;
  this._reopeningDelay = 1000;
  this._reopeningCount = 0;
  this._maxReopeningAttempts = 5;
  this._openingTimeoutDuration = 1000;
  this._openingTimeoutId = undefined;

  return this;

};

util.inherits(Phidget, EventEmitter);




//Phidget.prototype._cleanup = function(self) {
//console.log(&quot;CLEANUP!!!&quot;);
//  if (this._client) {
//    this._client.destroy();
//  }
//};

////process.stdin.resume();
//process.on(&#x27;exit&#x27;, function() {this._cleanup(self);} );
//process.on(&#x27;SIGINT&#x27;, function() {this._cleanup(self);} );
////process.on(&#x27;uncaughtException&#x27;, this._cleanup(self));


/**
 * Opens a connection to a Phidget device (via the webservice).
 *
 * @method open
 * @param {Object} options Options
 * @param {String} options.host Hostname or IP address to connect to
 * @param {int} options.port Port to connect to
 * @param {int} options.serial Serial of the device to connect to
 * @returns {Phidget} Returns the Phidget to allow method chaining
 */
Phidget.prototype.open = function(options) {

  var self = this;

  options = options || {};
  if (options.host)   { this.host = options.host; }
  if (options.port)   { this.port = options.port; }
  if (options.serial) { this.serial = options.serial; }

  /**
   * Event emitted when an attempt to open a Phidget has been initiated.
   *
   * @event opening
   * @param {Phidget} emitter The actual Phidget object that emitted the event.
   */
  self.emit(&#x27;opening&#x27;, self);

  // The function passed as a parameter is only executed when the &#x27;connect&#x27; event is
  // received.
  self._client = net.createConnection(self.port, self.host, function() {

    self._client.setEncoding(&#x27;utf8&#x27;);
    self._client.setKeepAlive(&quot;enable&quot;, 10000);

    self._client.on(&#x27;end&#x27;, function() {
      console.log(&quot;end end end&quot;);
      self._handleConnectionEnd(self);
    });

    self._client.on(&#x27;data&#x27;, function(d) {
      self._handleData(d, self);
    });

    self._client.write(&quot;995 authenticate, version=&quot; + self._protocol + self._delimiter);
    self._client.write(&quot;report 8 report&quot; + self._delimiter);

    // Open connection to web service
    var message  = &quot;set /PCK/Client/0.0.0.0/&quot; + self._randomId + &quot;/&quot; + self.type;

    // If a label has been specified, use it. If not, use the serial.
    //if (self.label !== undefined) {
    //  message   += &quot;/-1/&quot; + _escapeLabel(self.label);
    //} else if (self.serial !== -1) {
    if (self.serial &gt; 0) {
      message   += &quot;/&quot; + self.serial;
    }

    message += &quot;=\&quot;Open\&quot; for session&quot; + self._delimiter;
    self._client.write(message);

    // Listen message
    self._client.write(&quot;listen /PSK/&quot; + self.type + &quot; lid0&quot; + self._delimiter);

    // Here we have a challenge: if we connect successfully to the web service but the
    // device is not plugged in, we do not know. That&#x27;s why the device is set as ready
    // only when the following line is received: &#x27;report 200-periodic report follows:&#x27;. If
    // that line is not received within a certain delay, we must issue a timeout.
    self._openingTimeoutId = setTimeout(
      function() {
        /**
         * Event emitted when an attempt to open a Phidget times out.
         *
         * @event timeout
         * @param {Phidget} emitter The actual Phidget object that emitted the event.
         */
        self.emit(&#x27;timeout&#x27;, self);
        self._handleConnectionEnd(self);
      },
      self._openingTimeoutDuration
    );

  });

  self._client.on(&#x27;error&#x27;, function(e) {
    self._handleConnectionError(e, self);
  });

  return self;

};

/**
 * Closes a previously opened connection to a Phidget device (via the webservice).
 *
 * @method close
 * @returns {Phidget} Returns the Phidget to allow method chaining
 */
Phidget.prototype.close = function() {
  var self = this;
  self.reopen = false;
  self._client.write(&quot;quit\r\n&quot;);
  return self;
};

/** @private */
Phidget.prototype._handleConnectionEnd = function(self) {

  self._client.removeAllListeners([&#x27;end&#x27;, &#x27;close&#x27;, &#x27;error&#x27;, &#x27;data&#x27;]);
  self._client.end();
  self._client.destroy();
  //self._client.unref();
  self.ready = false;

  /**
   * Event emitted when the connection to a phidget has been remotely closed.
   *
   * @event closed
   * @param {Phidget} emitter The actual object that emitted the event.
   */
  self.emit(&#x27;closed&#x27;, self);

  // Attempt to reopen if configured as such
  if(self.reopen === true &amp;&amp; self._reopeningCount &lt; self._maxReopeningAttempts) {

    self._reopeningCount++;

    setTimeout(
      function() {
        /**
         * Event emitted when an attempt to automatically re-open a closed Phidget is
         * being carried on.
         *
         * @event reopening
         * @param {Phidget} emitter The actual Phidget object that emitted the event.
         * @param {Object} data Additional data regarding the event.
         * @param {int} data.attempt The number of re-opening attempts performed.
         * @param {int} data.max The maximum number of attempts that will be tried before
         * failing.
         */
        self.emit(
          &#x27;reopening&#x27;,
          self,
          {attempt: self._reopeningCount, max: self._maxReopeningAttempts}
        );
        self.open();
      },
      self._reopeningDelay
    );

  }
};

/** @private */
Phidget.prototype._handleConnectionError = function(e, self) {
  /**
   * Event emitted when an error occurs while trying to open a phidget
   *
   * @event error
   * @param {Phidget} emitter The actual object that emitted the event.
   * @param {Error} error The error object
   * @param {String} error.address The network address
   * @param {String} error.code The error code
   * @param {String} error.errno The error number
   * @param {String} error.message The error message
   * @param {String} error.port The network port
   */
  self.emit(&#x27;error&#x27;, self, e);

  self._handleConnectionEnd(self);

};

/** @private */
Phidget.prototype._handleData = function(chunk, self) {

  var index, line;

  chunk = chunk.toString(&#x27;utf8&#x27;);
  self._socketDataString += chunk;

  while( (index = self._socketDataString.indexOf(&#x27;\n&#x27;)) &gt; -1 ) {

    line = self._socketDataString.slice(0, index);
    self._socketDataString = self._socketDataString.slice(index + 1);
    line = line.replace(/\u0000/gi, &quot;&quot;);
    line = line.replace(/\u0001/gi, &quot;&quot;);

    /**
     * Event emitted when a new line of data has been received from the web service. This
     * is mostly useful for debugging purposes. It will let you view all data coming in.
     *
     * @event received
     * @param {Phidget} emitter The actual Phidget object that emitted the event.
     * @param {String} data The actual string data received.
     */
    self.emit(&#x27;received&#x27;, self, line);

    self._parseLineInput(line, self);

  }

};

/** @private */
Phidget.prototype._parseLineInput = function(line, self) {

  var err;

  //    200 set successful
  //    200 inter-report period adjusted to 8ms.
  //    200 listening, id lid0
  //    996 No need to authenticate, version=1.0.10

  // Split on spaces
  var status = line.split(&quot; &quot;)[0];

  if (status === &#x27;report&#x27;) {

    self._parseReport(line, self);

  //} else if(status === &#x27;200&#x27;) {

    // Positive response. Nothing to do.

  } else if(status === &#x27;994&#x27;) { // Version mismatch

    err = new Error(&#x27;Protocol version mismatch.&#x27;, &#x27;PROTOCOLMISMATCH&#x27;);
    err.details = line;
    self.emit(&#x27;error&#x27;, self, err);

  //} else if(status === &#x27;996&#x27;) { // Authenticated or no authentication necessary

    // Nothing to do.

  } else if(status === &#x27;998&#x27;) { // Authentication failed

    err = new Error(&#x27;Authentication failed&#x27;, &#x27;AUTHFAILED&#x27;);
    err.details = line;
    self.emit(&#x27;error&#x27;, self, err);

  //} else if(status === &#x27;999&#x27;) { // Authentication required

    // to complete!

  }

};

/** @private */
Phidget.prototype._parseReport = function(line, self) {

  // A typical report line looks like this (for DataRate, RawSensor, Sensor, Input, Output)
  //
  //    report 200-lid0 is pending, key /PSK/PhidgetInterfaceKit/mylabel/48587/Output/6 latest value &quot;0&quot; (changed)
  //    report 200-lid0 is pending, key /PSK/PhidgetInterfaceKit/mylabel/RawSensor/6 latest value &quot;0&quot; (removing)
  //
  // We extract the infos into an array
  //
  //    0: PSK
  //    1: PhidgetInterfaceKit
  //    2: mylabel
  //    3: 48587
  //    4: Output
  //    5: 6 latest value &quot;0&quot; (changed)
  //
  // A report line when the device is unplugged
  //
  //    report 200-lid0 is pending, key /PSK/PhidgetInterfaceKit/mylabel/48587/Status latest value &quot;Detached&quot; (removing)
  //
  // More examples that remain to be done:
  //
  //    report 200-lid0 is pending, key /PSK/PhidgetInterfaceKit/mylabel/48587/DataRate/5 latest value &quot;16&quot; (added)
  //    report 200-lid0 is pending, key /PSK/PhidgetInterfaceKit/mylabel/48587/DataRateMax latest value &quot;16&quot; (added)
  //    report 200-lid0 is pending, key /PSK/PhidgetInterfaceKit/mylabel/48587/DataRateMin latest value &quot;1000&quot; (added)
  //    report 200-lid0 is pending, key /PSK/PhidgetInterfaceKit/mylabel/48587/InitKeys latest value &quot;61&quot; (added)
  //    report 200-lid0 is pending, key /PSK/PhidgetInterfaceKit/mylabel/48587/InterruptRate latest value &quot;8&quot; (added)
  //    report 200-lid0 is pending, key /PSK/PhidgetInterfaceKit/mylabel/48587/ID latest value &quot;69&quot; (added)
  //    report 200-lid0 is pending, key /PSK/PhidgetInterfaceKit/mylabel/48587/NumberOfOutputs latest value &quot;8&quot; (added)
  //    report 200-lid0 is pending, key /PSK/PhidgetInterfaceKit/mylabel/48587/NumberOfInputs latest value &quot;8&quot; (added)
  //    report 200-lid0 is pending, key /PSK/PhidgetInterfaceKit/mylabel/48587/NumberOfSensors latest value &quot;8&quot; (added)
  //    report 200-lid0 is pending, key /PSK/PhidgetInterfaceKit/mylabel/48587/Ratiometric latest value &quot;1&quot; (added)
  //    report 200-lid0 is pending, key /PSK/PhidgetInterfaceKit/mylabel/48587/Status latest value &quot;Attached&quot; (added)
  //    report 200-lid0 is pending, key /PSK/PhidgetInterfaceKit/mylabel/48587/Status latest value &quot;Detached&quot; (removing)
  //    report 200-lid0 is pending, key /PSK/PhidgetInterfaceKit/mylabel/48587/Version latest value &quot;904&quot; (added)
  //    report 200-that&#x27;s all for now


  var parts = line.split(&quot;/&quot;).slice(1);

  if (!self.serial) {
    self.serial = parseInt(parts[3]);
  }

  //if (self.label === undefined) {
  //  self.label = infos[2];
  //}

  var type = parts[4];

  if (type &amp;&amp; type === &#x27;Status latest value &quot;Detached&quot; (removing)&#x27;) {

    self._handleConnectionEnd(self);

  } else if (
    type &amp;&amp;
    type.indexOf(&#x27;Name latest value &quot;&#x27;) === 0 &amp;&amp;
    type.indexOf(&quot;(added)&quot;) &gt; -1
  ) {

    // report 200-lid0 is pending, key /PSK/PhidgetInterfaceKit/mylabel/48587/Name latest value &quot;Phidget InterfaceKit 8/8/8&quot; (removing)
    // report 200-lid0 is pending, key /PSK/PhidgetInterfaceKit/mylabel/48587/Name latest value &quot;Phidget InterfaceKit 8/8/8&quot; (added)
    self.name = line.split(&#x27;&quot;&#x27;)[1];

  } else if (
    type &amp;&amp;
    type.indexOf(&#x27;Label latest value &quot;&#x27;) === 0 &amp;&amp;
    type.indexOf(&quot;(added)&quot;) &gt; -1
  ) {

    // report 200-lid0 is pending, key /PSK/PhidgetInterfaceKit/mylabel/48587/Label latest value &quot;mylabel&quot; (added)
    self.label = line.split(&#x27;&quot;&#x27;)[1];

  } else if (line === &#x27;report 200-periodic report follows:&#x27;) {

    // report 200-periodic report follows:

    if (self.ready === false) {

      self.ready = true;
      clearTimeout(self._openingTimeoutId);
      self._reopeningCount = 0;

      /**
       * Event emitted when a phidget is successfully opened.
       *
       * @event opened
       * @param {Phidget} emitter The actual Phidget object that emitted the event.
       */
      self.emit(&quot;opened&quot;, self);

    }

  } else {

    self._parsePhidgetSpecificReport(line, parts);

  }

};

/**
 * Parses &#x27;report&#x27; lines that are specific to one phidget model. Should be overridden by
 * subclasses
 *
 * @method _parsePhidgetSpecificReport
 * @param line {String} The raw line received from the webservice.
 * @param parts {Array} The raw line split on the &quot;/&quot; character.
 * @protected
 */
Phidget.prototype._parsePhidgetSpecificReport = function (line, parts) {

  var self = this;

  var type = parts[4];

  if (type === &#x27;Input&#x27; || type === &#x27;Output&#x27; || type === &#x27;Sensor&#x27;) {

    var infos = parts[5].split(&quot; &quot;);
    var index = parseInt(infos[0]);
    var value = parseInt(infos[3].replace(&#x27;&quot;&#x27;, &quot;&quot;));

    if (type === &quot;Input&quot;) {

      self.inputs[index] = (value === 1);

      /**
       * Event emitted when binary input data is received.
       *
       * @event input
       * @param {Phidget} emitter The actual Phidget object that emitted the event.
       * @param {Object} data An object containing the input data and related information
       * @param {int} data.index The input&#x27;s index number
       * @param {Boolean} data.value The input&#x27;s received value
       */
      self.emit(
        &quot;input&quot;,
        self,
        {&quot;index&quot;: index, &quot;value&quot;: value}
      );

    } else if (type === &quot;Sensor&quot;) {

      self.sensors[index] = value;

      /**
       * Event emitted when analog sensor data is received
       *
       * @event sensor
       * @param {Phidget} emitter The actual Phidget object that emitted the event.
       * @param {Object} data An object containing the sensor data and related information
       * @param {int} data.index The sensor&#x27;s index number
       * @param {int} data.value The sensor&#x27;s received value
       */
      self.emit(
        &quot;sensor&quot;,
        self,
        {&quot;index&quot;: index, &quot;value&quot;: value}
      );

    } else if (type === &quot;Output&quot;) {

      self.outputs[index] = value;

      /**
       * Event emitted when data is being outputted through one of the outputs
       *
       * @event output
       * @param {Phidget} emitter The actual Phidget object that emitted the event.
       * @param {Object} data An object containing the output data and related information
       * @param {int} data.index The sensor&#x27;s index number
       * @param {int} data.value The sensor&#x27;s received value
       */
      self.emit(
        &quot;output&quot;,
        self,
        {&quot;index&quot;: index, &quot;value&quot;: value}
      );

    }
  }

};


/**
 * @method _makeIndexedKey
 * @protected
 */
Phidget.prototype._makeIndexedKey = function (keyword, index) {
  var self = this;
  return &#x27;/PCK/&#x27; + self.type +&#x27;/&#x27;+self.serial+&#x27;/&#x27;+keyword+&#x27;/&#x27;+index;
};

/**
 * @method _sendKey
 * @protected
 */
Phidget.prototype._sendKey = function (key, value, persistent) {
  var self = this;
  var request = &quot;set &quot; + key + &quot;=\&quot;&quot; + value + &quot;\&quot;&quot;;
  if(!persistent) { request += &quot; for session&quot;; }
  self._client.write(request + self._delimiter);
  console.log(&#x27;request: &#x27; + request);
};

/**
 * @method _forceBetween
 * @protected
 */
Phidget.prototype._forceBetween = function(value, min, max) {
  return (Math.min(max, Math.max(min, value)));
};


//function _escapeLabel(val, escBacks) {
//
//  var esc = escBacks || false;
//
//  var newVal = &quot;&quot;;
//  if(val.length === 0) {
//    newVal = (esc ? &quot;\\\\x01&quot; : &quot;\\x01&quot;);
//  } else {
//    for (var i = 0; i &lt; val.length; i++) {
//      var charCode = val.charCodeAt(i);
//      if (!_isGoodChar(charCode)) {
//        newVal = newVal.concat((escBacks ? &quot;\\\\x&quot; : &quot;\\x&quot;) + _hexChar(charCode / 16) + _hexChar(charCode % 16));
//      } else {
//        newVal = newVal.concat(String.fromCharCode(charCode));
//      }
//    }
//  }
//  return newVal;
//}
//
//function _isGoodChar(charCode) {
//  var chars = &quot;09azAZ ./&quot;;
//  if(charCode &lt;= chars.charCodeAt(1) &amp;&amp; charCode &gt;= chars.charCodeAt(0)) { return true; }
//  if(charCode &lt;= chars.charCodeAt(3) &amp;&amp; charCode &gt;= chars.charCodeAt(2)) { return true; }
//  if(charCode &lt;= chars.charCodeAt(5) &amp;&amp; charCode &gt;= chars.charCodeAt(4)) { return true; }
//  if(
//    charCode === chars.charCodeAt(6) ||
//    charCode === chars.charCodeAt(7) ||
//    charCode === chars.charCodeAt(8)
//  ) { return true; }
//  return false;
//}
//
//function _hexChar(num) {
//  var chars = &quot;0123456789abcdef&quot;;
//  if(num &gt; 0xF) { return &quot;f&quot;; }
//  return chars.charAt(num);
//}







/****************************************************************************************/
/*********************************  PhidgetInterfaceKit  ********************************/
/****************************************************************************************/

/**
 * The PhidgetInterfaceKit class allows you to control and receive data from all Phidget
 * I/O boards :
 *
 *  * PhidgetAnalog 4-Output
 *  * PhidgetInterfaceKit 8/8/8 normal and mini-format
 *  * PhidgetInterfaceKit 2/2/2
 *  * PhidgetInterfaceKit 0/16/16
 *  * PhidgetInterfaceKit 8/8/8 (with and without hub)
 *  * PhidgetFrequencyCounter
 *  * etc.
 *
 * Not all these boards have been tested. If you possess one and can verify its
 * compatibility, let us know.
 *
 * @class PhidgetInterfaceKit
 * @constructor
 * @extends Phidget
 */
var PhidgetInterfaceKit = function() {
  PhidgetInterfaceKit.super_.call(this, &#x27;PhidgetInterfaceKit&#x27;);

  /**
   * An object containing the current value for all board inputs. The values are boolean.
   * To retrieve a value simply use the input number. For example:
   * PhidgetInterfaceKit.inputs[5].
   *
   * @property inputs
   * @type {{}}
   */
  this.inputs = {};

  /**
   * An object containing the current value for all board sensors. The values are
   * integers. To retrieve a vlaue simply use the sensor number. For example:
   * PhidgetInterfaceKit.sensors[5].
   *
   * @property sensors
   * @type {{}}
   */
  this.sensors = {};

  /**
   * An object containing the current value for all board outputs. The values are
   * boolean. To retrieve a value, simply use the output number. For example:
   * PhidgetInterfaceKit.outputs[5].
   *
   * @property outputs
   * @type {{}}
   */
  this.outputs = {};

};

util.inherits(PhidgetInterfaceKit, Phidget);

/**
 * Sets the specified output to active (true) or inactive (false).
 *
 * @method setOutput
 * @param {int} index The output number to set
 * @param {Boolean} value The value you wish to set the output to
 * @returns {Phidget} Returns the Phidget to allow method chaining
 */
PhidgetInterfaceKit.prototype.setOutput = function(index, value) {

  var self = this;
  if (self.ready !== true) { return self; }

  value = (value === true) ? true : false;
  index = self._forceBetween(index, 0, 7);
  var vOut = (value === true) ? 1 : 0;

  self.outputs[index] = value;
  self._sendKey(self._makeIndexedKey(&#x27;Output&#x27;, index), vOut, true);

  return self;

};

/**
 * Parses &#x27;report&#x27; lines received from the webservice that are specific to the
 * PhidgetInterfaceKit boards.
 *
 * @method _parsePhidgetSpecificReport
 * @param line {String} The raw line received from the webservice.
 * @param parts {Array} The raw line split on the &quot;/&quot; character.
 * @private
 */
PhidgetInterfaceKit.prototype._parsePhidgetSpecificReport = function (line, parts) {

  var self = this;

  var type = parts[4];

  if (type === &#x27;Input&#x27; || type === &#x27;Output&#x27; || type === &#x27;Sensor&#x27;) {

    var infos = parts[5].split(&quot; &quot;);
    var index = parseInt(infos[0]);
    var value = parseInt(infos[3].replace(&#x27;&quot;&#x27;, &quot;&quot;));

    if (type === &quot;Input&quot;) {

      self.inputs[index] = (value === 1);

      /**
       * Event emitted when binary input data is received.
       *
       * @event input
       * @param {PhidgetInterfaceKit} emitter The actual PhidgetInterfaceKit object that
       *        emitted the event.
       * @param {Object} data An object containing the input data and related information
       * @param {int} data.index The input&#x27;s index number
       * @param {Boolean} data.value The input&#x27;s received value
       */
      self.emit(
        &quot;input&quot;,
        self,
        {&quot;index&quot;: index, &quot;value&quot;: value}
      );

    } else if (type === &quot;Sensor&quot;) {

      self.sensors[index] = value;

      /**
       * Event emitted when analog sensor data is received
       *
       * @event sensor
       * @param {PhidgetInterfaceKit} emitter The actual PhidgetInterfaceKit object that
       *        emitted the event.
       * @param {Object} data An object containing the sensor data and related information
       * @param {int} data.index The sensor&#x27;s index number
       * @param {int} data.value The sensor&#x27;s received value
       */
      self.emit(
        &quot;sensor&quot;,
        self,
        {&quot;index&quot;: index, &quot;value&quot;: value}
      );

    } else if (type === &quot;Output&quot;) {

      self.outputs[index] = value;

      /**
       * Event emitted when data is being outputted through one of the outputs
       *
       * @event output
       * @param {PhidgetInterfaceKit} emitter The actual PhidgetInterfaceKit object that
       *        emitted the event.
       * @param {Object} data An object containing the output data and related information
       * @param {int} data.index The sensor&#x27;s index number
       * @param {int} data.value The sensor&#x27;s received value
       */
      self.emit(
        &quot;output&quot;,
        self,
        {&quot;index&quot;: index, &quot;value&quot;: value}
      );

    }
  }

};

/****************************************************************************************/
/*************************************  PhidgetLED  *************************************/
/****************************************************************************************/

/**
 * The PhidgetLED class allows you to control a PhidgetLED-64 Advanced board.
 *
 * @class PhidgetLED
 * @constructor
 * @extends Phidget
 */
var PhidgetLED = function() {
  PhidgetLED.super_.call(this, &#x27;PhidgetLED&#x27;);

  /**
   * An object containing the current value for all board outputs. The values are
   * integers between 0 and 100. To retrieve the value simply use the output number. For
   * example: PhidgetLED.outputs[5].
   *
   * @property outputs
   * @type {{}}
   */
  this.outputs = {};

};

util.inherits(PhidgetLED, Phidget);

/**
 * Adjusts the brightness of a LED.
 *
 * @method setBrightness
 * @param {int} index The LED to for which to adjust the brightness
 * @param {int} value The value (0-100) you wish to adjust the brightness to
 * @returns {Phidget} Returns the Phidget to allow method chaining
 */
PhidgetLED.prototype.setBrightness = function(index, value) {

  var self = this;
  if (self.ready !== true) { return self; }

  index = self._forceBetween(index, 0, 63);
  value = self._forceBetween(value, 0, 100);

  self._sendKey(self._makeIndexedKey(&#x27;Brightness&#x27;, index), value, true);
  self.outputs[index] = value;

  return self;

};






phidgets.Phidget = Phidget;
phidgets.PhidgetInterfaceKit = PhidgetInterfaceKit;
phidgets.PhidgetLED = PhidgetLED;
module.exports = phidgets;
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
